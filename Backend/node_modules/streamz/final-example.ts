import Streamz from './streamz';
import { Transform } from 'stream';

// Helper function for typed transforms
function createTypedTransform<T, R>(options: {
  transform: (chunk: T, encoding: BufferEncoding, callback: (error?: Error | null, data?: R) => void) => void;
}): Transform {
  return new Transform({
    objectMode: true,
    ...options
  });
}

async function demonstrateSolution() {
  console.log('üéØ Demonstrating typed piping solutions...\n');

  // Problem: Regular Transform loses type information
  console.log('‚ùå Problem - Regular Transform (chunk is any):');
  const processor1 = Streamz((d: string): number => d.length);
  
  const regularTransform = new Transform({
    objectMode: true,
    transform(chunk /* any */, encoding, callback) {
      // chunk is typed as 'any' - no type safety!
      console.log('  chunk type in regular Transform:', typeof chunk);
      callback(null, chunk * 2);
    }
  });

  // Solution 1: Use Streamz throughout (RECOMMENDED)
  console.log('\n‚úÖ Solution 1 - Pure Streamz pipeline:');
  const stringToNumber = Streamz((str: string): number => {
    console.log(`  Processing string: "${str}" -> ${str.length}`);
    return str.length;
  });
  
  const doubler = Streamz((num: number): number => {
    console.log(`  Doubling number: ${num} -> ${num * 2}`);
    return num * 2;
  });
  
  const formatter = Streamz((num: number): string => {
    const result = `Result: ${num}`;
    console.log(`  Formatting number: ${num} -> "${result}"`);
    return result;
  });

	doubler.pipe(Streamz(d => d));

  // Type-safe pipeline
  const pipeline = stringToNumber
    .pipe(doubler)      // number -> number
    .pipe(formatter);   // number -> string

  // Feed data
  stringToNumber.write('hello');
  stringToNumber.write('world');
  stringToNumber.end();

  const results = await pipeline.promise(); // string[]
  console.log('  Final results:', results);
  console.log('  Results type check - join method:', results.join(', '));

  // Solution 2: Typed Transform helper
  console.log('\n‚úÖ Solution 2 - Typed Transform helper:');
  const processor2 = Streamz((str: string): number => {
    console.log(`  Processing: "${str}" -> ${str.length}`);
    return str.length;
  });

  const typedTransform = createTypedTransform<number, string>({
    transform(chunk: number /* properly typed! */, encoding, callback) {
      console.log(`  Typed transform received number: ${chunk}`);
      const result = `Length was: ${chunk}`;
      callback(null, result);
    }
  });

  // Collect results manually for typed transform
  const typedResults: string[] = [];
  typedTransform.on('data', (chunk: string) => {
    typedResults.push(chunk);
  });

  typedTransform.on('end', () => {
    console.log('  Typed transform results:', typedResults);
  });

  processor2.pipe(typedTransform);
  processor2.write('test');
  processor2.write('example');
  processor2.end();

  console.log('\nüéâ Both solutions provide type safety!');
  console.log('üí° Recommendation: Use Solution 1 (Pure Streamz) for new code');
}

// Type checking demonstration
function typeCheckingDemo() {
  const a = Streamz((d: string): number => d.length);
  
  // This would cause a TypeScript error if uncommented:
  // const b = await a.promise();
  // const c = b / 100; // ‚ùå Error: can't divide array by number
  
  console.log('‚úÖ Type checking works - b is correctly typed as Promise<number[]>');
}

demonstrateSolution().catch(console.error);
typeCheckingDemo(); 