import Streamz from './streamz';
import { Transform } from 'stream';

// Helper function to create typed Transform streams
function createTypedTransform<T, R>(options: {
  transform: (chunk: T, encoding: BufferEncoding, callback: (error?: Error | null, data?: R) => void) => void;
  flush?: (callback: (error?: Error | null, data?: R) => void) => void;
}): Transform {
  return new Transform({
    objectMode: true,
    ...options
  });
}

async function demonstrateTypedPiping() {
  // Create a Streamz that converts strings to numbers
  const stringToNumber = Streamz((str: string): number => str.length);
  
  // Create a typed transform that knows it receives numbers
  const numberToString = createTypedTransform<number, string>({
    transform(chunk: number, encoding, callback) {
      // chunk is properly typed as number here!
      const result = `Length: ${chunk}`;
      callback(null, result);
    }
  });
  
  // Method 2: Using Streamz for type-safe chaining (recommended)
  const doubler = Streamz((num: number): number => num * 2);
  const formatter = Streamz((num: number): string => `Number: ${num}`);
  
  // Type-safe pipeline using Streamz
  const pipeline = stringToNumber
    .pipe(doubler)      // number -> number
    .pipe(formatter);   // number -> string
  
  // Feed some data
  stringToNumber.write('hello');
  stringToNumber.write('world');
  stringToNumber.write('test');
  stringToNumber.end();
  
  const results = await pipeline.promise(); // string[]
  console.log('Results:', results);
  
  // Demonstrate that results are properly typed as string[]
  const joinedResults: string = results.join(', '); // This works because results is string[]
  console.log('Joined:', joinedResults);
}

// Example showing the difference between typed and untyped transforms
async function compareTypedVsUntyped() {
  const processor = Streamz((data: string): number => data.charCodeAt(0));
  
  // Typed transform - chunk parameter is properly typed
  const typedTransformer = createTypedTransform<number, string>({
    transform(chunk: number, encoding, callback) {
      // TypeScript knows chunk is a number
      const result = String.fromCharCode(chunk);
      callback(null, result);
    }
  });
  
  // Regular Transform - chunk parameter is any
  const untypedTransformer = new Transform({
    objectMode: true,
    transform(chunk: any, encoding, callback) {
      // chunk is typed as any - no type safety
      const result = String.fromCharCode(chunk);
      callback(null, result);
    }
  });
  
  console.log('Both transforms work the same at runtime, but typed version provides compile-time safety');
}

// Export the helper for use in other files
export { createTypedTransform };

demonstrateTypedPiping().catch(console.error);
compareTypedVsUntyped().catch(console.error); 